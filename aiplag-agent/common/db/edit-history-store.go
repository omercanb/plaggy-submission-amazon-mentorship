// Containts the code for storing the diffs and the required metadata into an SQL database
package db

import (
	"aiplag-agent/daemon/models"
	"database/sql"
	"fmt"
	"log"
	"strings"
	"time"

	_ "github.com/mattn/go-sqlite3"
)

// EditHistoryStore manages persistent storage of edit events.
type EditHistoryStore struct {
	db                    *sql.DB
	insertEventStmt       *sql.Stmt
	getEventsByAssignStmt *sql.Stmt
}

// NewEditHistoryStore opens or creates a database at the given path and
// initializes the edit history schema.
func NewEditHistoryStore(dbPath string) (*EditHistoryStore, error) {
	db, err := InitDB(dbPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open DB: %w", err)
	}

	eh := &EditHistoryStore{db: db}
	if err := eh.initSchema(); err != nil {
		return nil, fmt.Errorf("failed to init schema: %w", err)
	}
	if err := eh.prepareStatements(); err != nil {
		return nil, fmt.Errorf("failed to prepare statements: %w", err)
	}

	return eh, nil
}

// AddAssignment inserts a new assignment and returns its autogenerated ID
func (eh *EditHistoryStore) AddAssignment(fullpath string) (int64, error) {
	result, err := eh.db.Exec("INSERT INTO assignments (path) VALUES (?)", fullpath)
	if err != nil {
		return 0, fmt.Errorf("failed to insert assignment: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return 0, fmt.Errorf("failed to get last insert id: %w", err)
	}

	return id, nil
}

// Assign a full path of the assignment corresponding to the assignment id
func (eh *EditHistoryStore) MapFullPathToAssignmentID(fullpath string, assignmentID int) error {
	_, err := eh.db.Exec("INSERT OR REPLACE INTO assignments (id, path) VALUES (?, ?)", assignmentID, fullpath)
	if err != nil {
		return fmt.Errorf("failed to insert assignment mapping: %w", err)
	}
	return nil
}

// GetAssignmentFullPaths returns a slice of all assignment paths stored in the database.
func (eh *EditHistoryStore) GetAssignmentFullPaths() ([]string, error) {
	rows, err := eh.db.Query(`SELECT path FROM assignments ORDER BY id ASC`)
	if err != nil {
		return nil, fmt.Errorf("failed to query assignment names: %w", err)
	}
	defer rows.Close()

	var assignments []string
	for rows.Next() {
		var path string
		if err := rows.Scan(&path); err != nil {
			return nil, fmt.Errorf("failed to scan assignment path: %w", err)
		}
		assignments = append(assignments, path)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("row iteration error: %w", err)
	}

	return assignments, nil
}

// GetAssignmentIDByFullPath returns the assignment ID whose path is a prefix of fullpath
func (eh *EditHistoryStore) GetAssignmentIDByFullPath(fullpath string) (int, error) {
	var id int
	// Order by length(path) DESC so that the longest matching prefix is chosen
	query := `
        SELECT id
        FROM assignments
        WHERE ? LIKE path || '%'
        ORDER BY LENGTH(path) DESC
        LIMIT 1
    `
	err := eh.db.QueryRow(query, fullpath).Scan(&id)
	if err != nil {
		return 0, fmt.Errorf("failed to find assignment for path %q: %w", fullpath, err)
	}
	return id, nil
}

// AddEvent records a new edit event in the database.
func (eh *EditHistoryStore) AddEvent(filePath string, eventType models.EditEventType, patch string) error {
	assignmentID, err := eh.GetAssignmentIDByFullPath(filePath)
	if err != nil {
		return fmt.Errorf("couldnt add event because of: %w", err)
	}
	_, err = eh.insertEventStmt.Exec(assignmentID, filePath, string(eventType), patch)
	return err
}

// GetEventsByAssignment returns all edit events associated with a given assignment ID.
func (eh *EditHistoryStore) GetEventsByAssignment(assignmentID int) ([]models.EditEvent, error) {
	rows, err := eh.getEventsByAssignStmt.Query(assignmentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var events []models.EditEvent
	for rows.Next() {
		var id, assignmentID int
		var filePath, eventTypeStr, patch, timestamp string

		if err := rows.Scan(&id, &assignmentID, &filePath, &eventTypeStr, &patch, &timestamp); err != nil {
			log.Printf("GetEventsByAssignment: failed to scan row: %v", err)
			continue
		}

		eventType, err := models.StringToEditEventType(eventTypeStr)
		if err != nil {
			log.Fatalf("GetEventsByAssignment: Wrong string stored in DB for event type: %v", eventTypeStr)
		}

		event := models.EditEvent{
			ID:           id,
			AssignmentID: assignmentID,
			Patch:        patch,
			FilePath:     filePath,
			EventType:    eventType,
		}
		// time.TFC3339 is the time format that sql uses
		event.Timestamp, err = time.Parse(time.RFC3339, timestamp)
		if err != nil {
			log.Fatalf("GetEventsByAssignment: Invalid time conversion: %v", timestamp)
		}
		events = append(events, event)
	}

	return events, rows.Err()
}

// DeleteEditsByFullPath deletes all stored edits for a given assignment path.
// Returns an error if something goes wrong.
func (eh *EditHistoryStore) DeleteEditsByFullPath(fullpath string) error {
	// Delete the assignment row itself
	fullpath = strings.TrimSpace(fullpath)
	_, err := eh.db.Exec(`DELETE FROM assignments WHERE path = ?`, fullpath)
	if err != nil {
		fmt.Println(err)
		return fmt.Errorf("failed to delete assignment row for path %s: %w", fullpath, err)
	}

	// Get the assignment ID for this path
	assignmentID, err := eh.GetAssignmentIDByFullPath(fullpath)
	if err != nil {
		return fmt.Errorf("failed to find assignment for path %q: %w", fullpath, err)
	}

	// Delete all edit events for this assignment
	_, err = eh.db.Exec(`DELETE FROM edit_history WHERE assignment_id = ?`, assignmentID)
	if err != nil {
		return fmt.Errorf("failed to delete edits for assignment ID %d: %w", assignmentID, err)
	}

	return nil
}

func (eh *EditHistoryStore) initSchema() error {
	schema := `
	CREATE TABLE IF NOT EXISTS edit_history (
		id INTEGER PRIMARY KEY AUTOINCREMENT,
		assignment_id int,
		file_path TEXT NOT NULL,
		event_type TEXT NOT NULL,
		patch TEXT,
		timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
	);
	CREATE INDEX IF NOT EXISTS idx_assignment ON edit_history(assignment_id);

	CREATE TABLE IF NOT EXISTS assignments (
	    id INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT UNIQUE NOT NULL
	);
	`
	_, err := eh.db.Exec(schema)
	return err
}

func (eh *EditHistoryStore) prepareStatements() error {
	var err error
	eh.insertEventStmt, err = eh.db.Prepare(`
		INSERT INTO edit_history (assignment_id, file_path, event_type, patch, timestamp)
		VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP)
	`)
	if err != nil {
		return fmt.Errorf("prepare insertEventStmt: %w", err)
	}

	eh.getEventsByAssignStmt, err = eh.db.Prepare(`
		SELECT id, assignment_id, file_path, event_type, patch, timestamp
		FROM edit_history
		WHERE assignment_id = ?
		ORDER BY timestamp ASC
	`)
	if err != nil {
		return fmt.Errorf("prepare getEventsByAssignStmt: %w", err)
	}

	return nil
}

func (eh *EditHistoryStore) Close() error {
	stmts := []*sql.Stmt{
		eh.insertEventStmt,
		eh.getEventsByAssignStmt,
	}
	for _, stmt := range stmts {
		if stmt != nil {
			stmt.Close()
		}
	}
	if eh.db != nil {
		return eh.db.Close()
	}
	return nil
}

// DebugPrint prints all stored edit events for debugging purposes.
func (eh *EditHistoryStore) DebugPrint() {
	rows, err := eh.db.Query(`SELECT id, assignment_id, file_path, event_type, patch, timestamp FROM edit_history ORDER BY timestamp ASC`)
	if err != nil {
		log.Printf("DebugPrint: failed to query edit_history: %v", err)
		return
	}
	defer rows.Close()

	for rows.Next() {
		var id, assignmentID int
		var filePath, eventType, patch, timestamp string

		if err := rows.Scan(&id, &assignmentID, &filePath, &eventType, &patch, &timestamp); err != nil {
			log.Printf("DebugPrint: failed to scan row: %v", err)
			continue
		}

		truncatedPatch := patch
		if len(truncatedPatch) > 200 {
			truncatedPatch = truncatedPatch[:200] + "..."
		}

		fmt.Printf("ID: %d, AssignmentID: %d, FilePath: %s, EventType: %s, Timestamp: %s, Patch: %s\n",
			id, assignmentID, filePath, eventType, timestamp, truncatedPatch)
	}

	if err := rows.Err(); err != nil {
		log.Printf("DebugPrint: rows iteration error: %v", err)
	}
}
